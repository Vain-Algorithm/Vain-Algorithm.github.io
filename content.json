{"pages":[],"posts":[{"title":"ABA的个数","text":"题意: 给一个只包含大写字母的字符串，求其中有多少个ABA(不一定连续)举个栗子: ABBBA 这个样例有3个ABA 样例: 输入: YARBRBAQTYAYBATTBLBZA 输出 26 思路:可以先把字符串中的A B取出，按原序放到一个新数组str[ ]中，然后依次预处理，A的数量，AB的数量，ABA的数量，我们可以开三个数组来处理他们，da[ ]，dab[]，daba[]，最终存ABA数量的数组可以由之前两个推出 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int inf = 1 &lt;&lt; 30;const int maxn = 1e6 + 5;typedef long long ll;//const int N = 5005;typedef unsigned long long ull;char s[maxn], str[maxn];ll da[maxn], dab[maxn], daba[maxn];int main(){ ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; s + 1; ll n = strlen(s + 1); ll cnt = 0; for (int i = 1; i &lt;= n; i++) { if (s[i] == 'A' || s[i] == 'B') str[++cnt] = s[i]; } for (int i = 1; i &lt;= cnt; i++) { if (str[i] == 'A') da[i] = da[i - 1] + 1; else da[i] = da[i - 1]; } for (int i = 1; i &lt;= cnt; i++) { if (str[i] == 'B') dab[i] = dab[i - 1] + da[i]; else dab[i] = dab[i - 1]; } for (int i = 1; i &lt;= cnt; i++) { if (str[i] == 'A') daba[i] = daba[i - 1] + dab[i]; else daba[i] = daba[i - 1]; } cout&lt;&lt;daba[cnt]&lt;&lt;endl;}","link":"/2020/04/19/ABA%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"AtCoder 4351前缀和+二分+求顺序对数","text":"题意： 题目链接 给一个长为N的序列，求出所有子区间中位数组成的新序列的中位数 思路：首先我们需要找到这个题的可二分性: 我们可以知道中位数的性质:在序列中，比中位数小的个数有差不多N/2个，呢么比中位数大的差不多也有N/2个，由此我们找到了可二分性，所以我们就可以二分答案 得到序列中所有中位数比mid大的区间个数：(1) 首先利用前缀和处理数组，将不小于mid的赋为1，其余赋为-1，这样我们就可以得到原序列中的前缀区间的值(2) 利用树状数组求前缀和位置的所有顺序对数，这样就可以求出中位数大于mid的区间个数 参考代码：* 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const ll maxn = 1e5 + 5;vector&lt;ll&gt; vec;ll n, sum[maxn * 10], c[maxn * 10], a[maxn];ll lowbit(ll x){ return x &amp; (-x);}void modify(ll i){ while (i &lt;= 2 * maxn) { ++c[i]; i += lowbit(i); }}ll getsum(ll i){ ll res = 0; while (i &gt; 0) { res += c[i]; i -= lowbit(i); } return res;}bool check(ll mid){ memset(c, 0, sizeof c); for (ll i = 1; i &lt;= n; i++) sum[i] = sum[i - 1] + (a[i] &gt;= mid ? 1 : -1); ll res = 0; for (ll i = 0; i &lt;= n; i++) { res += getsum(sum[i] + maxn); modify(sum[i] + maxn); } if (res &gt;= ((n + 1) * n / 4)) return true; return false;}int main(){ ios::sync_with_stdio(false); cin.tie(0); ll l = 0, r = 0; cin &gt;&gt; n; for (ll i = 1; i &lt;= n; i++) cin &gt;&gt; a[i], r = max(r, a[i]); ll ans = 0; while (l &lt;= r) { ll mid = l + r &gt;&gt; 1; if (check(mid)) l = mid + 1, ans = mid; else r = mid - 1; } cout &lt;&lt; ans &lt;&lt; endl;}","link":"/2020/05/05/AtCoder-4351%E5%89%8D%E7%BC%80%E5%92%8C-%E4%BA%8C%E5%88%86-%E6%B1%82%E9%A1%BA%E5%BA%8F%E5%AF%B9%E6%95%B0/"},{"title":"O(n)哈希检验求最长回文子串","text":"求最长回文子串，大家公认的算法是Manacher，但是如果我们不想学习Mangacher，又想在 O(n) 的时间复杂度下解决该问题怎么办？ 哈希算法可以帮我们做到，而且容易理解，代码还很短 举个栗子现在有字符串 str=&quot;cbaaab&quot;，我们要求它的回文子串，那么该怎么办呢？这里我们借用Manacher算法里的一个思想，向原字符串里插字符，使得这个字符串为奇数个，这样方便我们统一处理。我们在这个栗子中插入'#' 原字符:c b a a a b现字符:# c # b # a # a # a # b # 接下来: 先求出现字符串的正哈希 在求出现字符串的逆哈希 定义最长回文串半径 枚举字符串中的点 检验当前点的正哈希[i-l,i] 和 [i+l,i]是否相同 若相同扩大半径，反则退出循环 更新最大回文半径，记录ans 输出ans-1即可 推荐题目: 回文子串的最大长度 参考代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int inf = 1 &lt;&lt; 30;const int maxn = 2e6 + 5;typedef long long ll;//const int N = 5005;char s[maxn], str[maxn];typedef unsigned long long ull;ull h1[maxn], h2[maxn], p[maxn];int main(){ ios::sync_with_stdio(false); cin.tie(0); int id = 0; while (cin &gt;&gt; (s + 1) &amp;&amp; s[1] != 'E') { int n = strlen(s + 1); int t = 0; for (int i = 1; i &lt;= n; i++) { str[++t] = 'z'; str[++t] = s[i]; } str[++t] = 'z'; p[0] = 1ull; for (int i = 1; i &lt;= t; i++) { h1[i] = h1[i - 1] * 131ull + str[i] - 'a' + 1ull; h2[t - i + 1] = h2[t - i + 2] * 131ull + str[t - i + 1] - 'a' + 1ull; p[i] = p[i - 1] * 131ull; } int l, ans = 0, j = 0; for (int i = 1; i &lt;= t; i++) { l = ans; bool fla = false; while (h1[i] - h1[i - l] * p[l] == h2[i] - h2[i + l] * p[l] &amp;&amp; i + l &lt;= t &amp;&amp; i - l &gt;= 1) l++, fla = true; if (fla &amp;&amp; i + l &lt;= t &amp;&amp; i - l &gt;= 1) --l; ans = max(l, ans); } cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++id &lt;&lt; &quot;: &quot; &lt;&lt; ans - 1 &lt;&lt; endl; }}","link":"/2020/04/19/O-n-%E5%93%88%E5%B8%8C%E6%A3%80%E9%AA%8C%E6%B1%82%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"title":"HDU 3282 动态开点+区间第k小","text":"题意: 给n个数，把这n个数以此插入容器中，当插入的数量是奇数个时输出中位数 样例: Sample Input31 91 2 3 4 5 6 7 8 92 99 8 7 6 5 4 3 2 13 2323 41 13 22 -3 24 -31 -11 -8 -73 5 103 211 -311 -45 -67 -73 -81 -99-33 24 56 Sample Output1 51 2 3 4 52 59 8 7 6 53 1223 23 22 22 13 3 5 5 3 -3-7 -3 吐槽: 今天有点事，没看来得及看这道题，其实就是询问整体区间第k小的板题 思路: 我没怎么看数据范围，直接用动态开点线段树写了，当然这题数据范围很小，普通线段树也可以写，因为数据范围并不是很大，如果数据范围给到1e9，那也只能动态开点或者离散化写了，这题主要考察权值线段树，我们可以统计权值，我们询问的值如果小于等于左儿子节点的权值，呢么我们询问的值一定在左边，我们向左递归，反之减去左边权值向右递归 参考代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int inf = 1 &lt;&lt; 30;const int maxn = 1e6 + 5;typedef long long ll;const int N = 1005;typedef unsigned long long ull;//char s[maxn], str[maxn], s3[maxn];//char s[N][N];//ll da[maxn], dab[maxn], daba[maxn], sum[maxn];int a[maxn];struct node{ int ls, rs, sum;} tr[maxn &lt;&lt; 1];int cnt;void inser(int &amp;k, int L, int R, int pos){ if (!k) k = ++cnt; tr[k].sum++; if (L == R) { return; } int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[k].ls, L, mid, pos); else inser(tr[k].rs, mid + 1, R, pos);}int ask(int k, int L, int R, int ik){ if (L == R) { return L; } int mid = L + R &gt;&gt; 1; int sum = tr[tr[k].ls].sum; if (sum &gt;= ik) return ask(tr[k].ls, L, mid, ik); else return ask(tr[k].rs, mid + 1, R, ik - sum);}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, m, k; int t; cin &gt;&gt; t; while (t--) { memset(a, 0, sizeof a); memset(tr, 0, sizeof(tr)); cin &gt;&gt; m &gt;&gt; n; k = cnt = 0; int x, id = 0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; inser(k, -inf, inf, x); if (i &amp; 1) { int pos = (1 + i) / 2; a[id++] = ask(k, -inf, inf, pos); } } cout &lt;&lt; m &lt;&lt; ' ' &lt;&lt; (n + 1) / 2 ; for (int i = 0; i &lt;id; i++) { if (i % 10 == 0) cout &lt;&lt; endl; if (i % 10 == 0) cout &lt;&lt; a[i]; else cout &lt;&lt; ' ' &lt;&lt; a[i]; } cout&lt;&lt;endl; }}","link":"/2020/04/19/HDU-3282-%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9-%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%B0%8F/"},{"title":"SPOJ DQUERY(主席树)","text":"传送门 题意：给长度为n的序列，询问区间中的元素个数(去重后的元素个数），m次询问，$n在[1,310^4], m在[1,210^5]$。 思路：用主席树去写，每颗树存从[1,i]区间的信息，我们把这颗树中出现多次的数去重，只保最每个数在最右边出现的位置信息，其余位置的sum为0，然后询问时候，在含有当前区间信息的树中，进行区间求和 参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 1e5 + 5;vector&lt;int&gt; vec;struct node{ int ls, rs, sum;} tr[maxn * 50];int rt[maxn], cnt;void inser(int ver, int &amp;now, int L, int R, int pos, int w){ now = ++cnt; tr[now] = tr[ver]; tr[now].sum = tr[ver].sum + w; if (L == R) return; int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[ver].ls, tr[now].ls, L, mid, pos, w); else inser(tr[ver].rs, tr[now].rs, mid + 1, R, pos, w);}int ask(int now, int L, int R, int ql, int qr){ if (L &gt;= ql &amp;&amp; R &lt;= qr) return tr[now].sum; int mid = L + R &gt;&gt; 1; int ans = 0; if (ql &lt;= mid) ans += ask(tr[now].ls, L, mid, ql, qr); if (qr &gt; mid) ans += ask(tr[now].rs, mid + 1, R, ql, qr); return ans;}map&lt;int, int&gt; mp;int main(){ ios::sync_with_stdio(false); cin.tie(0); mp.clear(); int n, x; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; if (!mp[x]) inser(rt[i - 1], rt[i], 1, n, i, 1); else inser(rt[i - 1], rt[i], 1, n, mp[x], -1), inser(rt[i], rt[i], 1, n, i, 1); mp[x] = i; } int m; cin &gt;&gt; m; while (m--) { int ql, qr; cin &gt;&gt; ql &gt;&gt; qr; cout &lt;&lt; ask(rt[qr], 1, n, ql, qr) &lt;&lt; endl; }}","link":"/2020/05/03/SPOJ-DQUERY-%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"title":"bbb群主的快读板子","text":"ios对cin的加速欺骗了我，md数据量稍微大一点就TLE了，不太靠谱，搞一波bbb群主的快读板子，用于对付卡常用，虽然一般感觉用不到叭，scanf够用了，但搞上一波没啥坏处 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687using namespace std;typedef long long ll;#define repi(i,b,e) for (int i = (b), _ = (e); i &lt; _; ++i)#define rep(i,b,e) for (int i = (b), _ = (e); i &lt;= _; ++i)#define repr(i,b,e) for (int i = (b), _ = (e); i &gt;= _; --i)#define repit(t,i,c) for (t i = (c).begin(); i != (c).end(); ++i)template &lt;typename T&gt;T&amp; up_mx(T&amp; v, T nv){ if (v &lt; nv) v = nv; return v;}template &lt;typename T&gt;T&amp; up_mn(T&amp; v, T nv){ if (v &gt; nv) v = nv; return v;}static int sc_ret = 0;struct _sp{ _sp&amp; operator &gt;&gt; (char&amp; v) { sc_ret = scanf(\" %c\", &amp;v); return *this; } _sp&amp; operator &gt;&gt; (int&amp; v) { sc_ret = scanf(\"%d\", &amp;v); return *this; } _sp&amp; operator &gt;&gt; (unsigned&amp; v) { sc_ret = scanf(\"%u\", &amp;v); return *this; } _sp&amp; operator &gt;&gt; (double&amp; v) { sc_ret = scanf(\"%lf\", &amp;v); return *this; } _sp&amp; operator &gt;&gt; (char* v) { sc_ret = scanf(\"%s\", v); return *this; } _sp&amp; operator &gt;&gt; (string&amp; v) { sc_ret = (bool)(cin &gt;&gt; v); return *this; } _sp&amp; operator &gt;&gt; (ll&amp; v) { sc_ret = read(v); return *this; } _sp&amp; ch(char&amp; v) { v = sc_ret = getchar(); return *this; } _sp&amp; gets(char* v) { sc_ret = fgets(v, INT_MAX, stdin) != 0; v[strlen(v) - 1] = 0; return *this; } operator bool() const { return sc_ret &gt; 0; } template &lt;typename T&gt; int read(T&amp; v) { T k = 1; v = 0; int c = getchar(); while (c &lt; '0' || c &gt; '9') { if (c == '-') k = 0; c = getchar(); } while (c &gt;= '0' &amp;&amp; c &lt;= '9') v = (v &lt;&lt; 3) + (v &lt;&lt; 1) + (c - 48), c = getchar(); if (k == 0) v = -v; return c; } _sp&amp; operator&lt;&lt;(char v) { putchar(v); return *this; } _sp&amp; operator&lt;&lt;(int v) { printf(\"%d\", v); return *this; } _sp&amp; operator&lt;&lt;(unsigned v) { printf(\"%u\", v); return *this; } _sp&amp; operator&lt;&lt;(double v) { printf(\"%.2f\", v); return *this; } _sp&amp; operator()(const char* fmt, double v) { printf(fmt, v); return *this; } _sp&amp; operator&lt;&lt;(const char* v) { printf(\"%s\", v); return *this; } _sp&amp; operator&lt;&lt;(string v) { printf(\"%s\", v.c_str()); return *this; } _sp&amp; operator&lt;&lt;(ll v) { write(v); return *this; } void flush() { fflush(stdout); } template &lt;typename T&gt; void write(T v) { int cnt = 0; char c[23]; if (v == 0) { putchar('0'); return; } if (v &lt; 0) putchar('-'), v = -v; while (v) c[++cnt] = (v % 10) + 48, v /= 10; while (cnt &gt; 0) putchar(c[cnt--]); }}io;struct fastio{ fastio() { cin.tie(0); ios::sync_with_stdio(0); } }fio;namespace cio{ _sp&amp; qin = io; _sp&amp; qout = io; char nl = '\\n'; }namespace cppio{ istream&amp; qin = std::cin; ostream&amp; qout = std::cout; char nl = '\\n'; }using namespace cio;template &lt;typename T&gt;void arrln(T* arr, int size, char split = ' '){ if (size &gt; 0) { qout &lt;&lt; arr[0]; for (int i = 1; i &lt; size; ++i) qout &lt;&lt; split, qout &lt;&lt; arr[i]; } qout &lt;&lt; '\\n';}","link":"/2020/05/08/bbb%E7%BE%A4%E4%B8%BB%E7%9A%84%E5%BF%AB%E8%AF%BB%E6%9D%BF%E5%AD%90/"},{"title":"Leetcode 1438. 绝对差不超过限制的最长连续子数组","text":"传送门： 题意： 给长度为 n 的序列 和 限制值 k，求最长的子区间，子区间满足区间中任意两个数的差的绝对值不大于k 思路：双单调队列，一个维护当前区间最大，一个维护当前区间最小，如果当前区间最大-最小满足条件，呢么当前区间整体满足条件，否则让单调队列中的除去当前存在的左端点即可 参考代码： 12345678910111213141516171819202122232425262728293031323334class Solution {int ans;int q1[100005], q2[100005], a[100005];void solv(int n, int k){ int head1 = 0, tail1 = -1, head2 = 0, tail2 = -1, res = 0, l = 0; for (int i = 0; i &lt; n; i++) { while (head1 &lt;= tail1 &amp;&amp; a[q1[tail1]] &gt;=a[i]) tail1--; while (head2 &lt;= tail2 &amp;&amp; a[q2[tail2]] &lt;=a[i]) tail2--; while (head1 &lt;= tail1 &amp;&amp; q1[head1] &lt; l) head1++; while (head2 &lt;= tail2 &amp;&amp; q2[head2] &lt; l) head2++; q1[++tail1] = i; q2[++tail2] = i; if (a[q2[head2]] - a[q1[head1]] &lt;= k) res = max(res, i - l + 1); else l++; } ans=res;}public: int longestSubarray(vector&lt;int&gt;&amp; nums, int limit) { int n=nums.size(); for(int i=0;i&lt;n;i++) a[i]=nums[i]; solv(n,limit); return ans; }};","link":"/2020/05/09/leetcode-1438-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E4%B8%8D%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/"},{"title":"Fhq treap","text":"传送门： 学了Fhq Treap之后，我深深的了解到 Fhq Treap的牛逼，因为上一张学了替罪羊平衡树，码量很大，操作繁琐，不支持提取区间信息，虽然简单理解，但是Fhq也很好理解呀，而且码量不大，能快速维护一颗平衡树，支持提取区间信息 Fhq Treap 的骚操作: 分裂 合并 分裂：* 分裂操作其实很简单理解，把一颗平衡树按照插入的值为界限，分裂成两棵树，记录两个树的根节点即可 合并： 合并的规则根据随机索引去合并二叉堆即可，这样这棵树就很难因为出题人造的数据而退化为一条链，除非运气十分的不好 参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;#include &lt;random&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 1e6 + 5;vector&lt;int&gt; vec;struct node{ int ls, rs, w, key; int sizx;} tr[maxn * 32];int cnt, rt;int newnode(int w){ tr[++cnt].w = w, tr[cnt].key = rand(); tr[cnt].sizx = 1; return cnt;}void pushup(int now){ tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1;}void split(int now, int w, int &amp;x, int &amp;y){ if (!now) x = y = 0; else { if (tr[now].w &lt;= w) { x = now, split(tr[now].rs, w, tr[now].rs, y); } else { y = now, split(tr[now].ls, w, x, tr[now].ls); } pushup(now); }}int merge(int x, int y){ if (!x || !y) return x + y; if (tr[x].key &gt; tr[y].key) { tr[x].rs = merge(tr[x].rs, y); pushup(x); return x; } else { tr[y].ls = merge(x, tr[y].ls); pushup(y); return y; }}int x, y, z;void inser(int w){ split(rt, w, x, y); rt = merge(merge(x, newnode(w)), y);}void dele(int w){ split(rt, w, x, z); split(x, w - 1, x, y); y = merge(tr[y].ls, tr[y].rs); rt = merge(merge(x, y), z);}void getrank(int w){ split(rt, w - 1, x, y); cout &lt;&lt; tr[x].sizx + 1 &lt;&lt; endl; rt = merge(x, y);}void getnum(int rank){ int now = rt; while (now) { if (tr[tr[now].ls].sizx + 1 == rank) break; else if (tr[tr[now].ls].sizx &gt;= rank) now = tr[now].ls; else { rank -= tr[tr[now].ls].sizx + 1; now = tr[now].rs; } } cout &lt;&lt; tr[now].w &lt;&lt; endl;}void pre(int w){ split(rt, w - 1, x, y); int now = x; while (tr[now].rs) now = tr[now].rs; cout &lt;&lt; tr[now].w &lt;&lt; endl; rt = merge(x, y);}void nxt(int w){ split(rt, w, x, y); int now = y; while (tr[now].ls) now = tr[now].ls; cout &lt;&lt; tr[now].w &lt;&lt; endl; rt = merge(x, y);}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n; cin &gt;&gt; n; while (n--) { int op, x; cin &gt;&gt; op &gt;&gt; x; switch (op) { case 1: inser(x); break; case 2: dele(x); break; case 3: getrank(x); break; case 4: getnum(x); break; case 5: pre(x); break; case 6: nxt(x); break; } }}","link":"/2020/05/02/Fhq-treap/"},{"title":"Leetcode 三数之和","text":"题目链接:三数之和题意：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为： 1234[ [-1, 0, 1], [-1, -1, 2]] 思路: 双指针+剪枝，具体操作看代码 参考代码： 12345678910111213141516171819202122232425262728293031323334class Solution{map&lt;int,int&gt;mp;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt; &amp;nums) { sort(nums.begin(), nums.end()); vector&lt;vector&lt;int&gt;&gt; vec; int n = nums.size(); string s; for (int i = 0; i &lt; n; i++) { int l = i + 1, j = i + 2; if(mp[nums[i]]) continue; mp[nums[i]]=1; while (j &lt; n) { while ((nums[i] + nums[l] + nums[j]) &lt; 0 &amp;&amp; l &lt; j &amp;&amp; j &lt; n) l++; while ((nums[i] + nums[l] + nums[j]) &gt; 0 &amp;&amp; l &gt; i + 1 &amp;&amp; l &lt; j) l--; if ((nums[i] + nums[l] + nums[j]) == 0 &amp;&amp; l &lt; j &amp;&amp; j &lt; n) { vec.push_back(vector&lt;int&gt;{nums[i], nums[l], nums[j]}); } j++; } } sort(vec.begin(), vec.end()); vec.erase(unique(vec.begin(), vec.end()), vec.end()); return vec; }};","link":"/2020/05/11/leetcode-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"可持久化数组","text":"可持久化数组 可持久化数组其实就是保存了历史版本的数组。对于历史版本，我们需要开一个rt[ ]来保存，当前版本的根节点，我们通过根节点的索引，可以，找到当前版本的树中，所携带rt[0]-rt[i]这个区间，的任意点的信息。 题目描述 如题，你需要维护这样的一个长度为 NN 的数组，支持如下几种操作，在某个历史版本上修改某一个位置上的值，访问某个历史版本上的某一位置的值，此外，每进行一次操作（对于操作2，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组） 输入格式 输入的第一行包含两个正整数 N, MN,M， 分别表示数组的长度和操作的个数。第二行包含NN个整数，依次为初始状态下数组各位的值（依次为 ai，1≤i≤N）接下来MM行每行包含3或4个整数，代表两种操作之一（ii为基于的历史版本号）： 1:对于操作1，格式为v 1 loc value ，即为在版本v的基础上，将 loc位置的值修改为 value​ 2:对于操作2，格式为v 1 loc ，即为在版本v的基础上，询问loc位置的值 输出格式 输出包含若干行，依次为每个操作2的结果。 输入输出样例 输入 10123456789101159 46 14 87 410 2 10 1 1 140 1 1 570 1 1 884 2 40 2 50 2 44 2 12 2 21 1 5 91 输出 123456598741878846 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 1e6 + 5;struct node{ int ls, rs, w;} tr[maxn * 32];int a[maxn], rt[maxn], cnt;void inser(int ver, int &amp;now, int L, int R, int pos, int w){ now = ++cnt; tr[now] = tr[ver]; if (L == R) { tr[now].w = w; return; } int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[ver].ls, tr[now].ls, L, mid, pos, w); else inser(tr[ver].rs, tr[now].rs, mid + 1, R, pos, w);}int ask(int now, int L, int R, int pos){ if (L == R) return tr[now].w; int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) return ask(tr[now].ls, L, mid, pos); else return ask(tr[now].rs, mid + 1, R, pos);}int main(){ int n, m, x; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;x), inser(rt[0], rt[0], 1, n, i, x); for (int i = 1; i &lt;= m; i++) { int ba, op, pos, w; scanf(&quot;%d %d&quot;, &amp;ba, &amp;op); if (op == 1) { scanf(&quot;%d %d&quot;, &amp;pos, &amp;w); inser(rt[ba], rt[i], 1, n, pos, w); } else { scanf(&quot;%d&quot;, &amp;pos); int ans = ask(rt[ba], 1, n, pos); printf(&quot;%d\\n&quot;, ans); rt[i] = rt[ba]; } }}","link":"/2020/04/24/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E7%BB%84/"},{"title":"我的第一篇博客","text":"Hexo 常用命令详解1:hexo inithexo init 命令用于初始化本地文件夹为网站的根目录 $ hexo init [folder] folder 可选参数, 可以指定初始化目录的路径, 若无指定则默认当前目录 2:hexo newhexo new 命令用于新建文章, 一般可以简写为 hexo n$ hexo new [layout] &lt;title&gt; layout 可选参数, 用以指定文章类型, 若无指定则默认由配置文件中的 default_layout选项决定 title 必填参数，可以用以指定文章标题，如果参数中含有空格，则需要使用双引号包围 3:hexo generatehexo generate 命令用于生成静态文件, 一般可以简写为hexo g$ hexo generate*-d 选项, 指定生成后部署，与hexo d -g等价 4:hexo serverhexo server 命令用于启动本地服务器, 一般可以简写为hexo s$ hexo server -p选项，指定服务器端口, 默认为 4000 -i选项，指定服务器 IP 地址, 默认为 0.0.0.0 -s选项, 静态模式 , 仅提供 public 文件夹中的文件并禁用文件监视 说明: 运行服务器前需要安装 hexo-server 插件$ npm install hexo-server --save 5:hexo deployhexo deploy 命令用于部署网站, 一般可以简写为 hexo d $ hexo deploy 6:hexo cleanhexo clean 命令用于清理缓存文件, 是一个比较常用的命令网站显示异常时可尝试此操作 7: Option(1) hexo –safehexo --safe 表示安全模式, 用于禁用加载插件和脚本$ hexo --safe安装新插件时遇到问题可尝试此操作(2) hexo –debughexo --debug 表示调试模式, 用于将消息详细记录到终端和debug.log文件(3)hexo –silenthexo --silent 表示静默模式, 用于静默输出到终端$ hexo --silent","link":"/2020/04/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"Leetcode 切分数组","text":"dp + 筛最小素因子 + 枚举最小素因子切分数组: 给定一个整数数组 nums ，小李想将 nums 切割成若干个非空子数组，使得每个子数组最左边的数和最右边的数的最大公约数大于 1 。为了减少他的工作量，请求出最少可以切成多少个子数组。示例 1：输入：nums = [2,3,3,2,3,3]输出：2解释：最优切割为 [2,3,3,2] 和 [3,3] 。第一个子数组头尾数字的最大公约数为 2 ，第二个子数组头尾数字的最大公约数为 3 。示例 2：输入：nums = [2,3,5,7]输出：4解释：只有一种可行的切割：[2], [3], [5], [7] 限制： 1 &lt;= nums.length &lt;= 10^5 2 &lt;= nums[i] &lt;= 10^6 思路: 首先我们先筛出最大数据以内(包括最大数据)所有数对应的最小素因子 推导dp方程 1:当前i位置所对应的数的组数 = min(当前i位置对应的最小素因子的位置,dp[i]+1)2:当前i位置对应的最小素因子的位置= min(min[a[i]]，dp[i-1]) 枚举每个数的最小的最小素因子所对应的位置 因为当前数可能有好多素因子，所以我们把他除以他的最小素因子，呢么得到的数就会对应本身的最小素因子 参考代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 1e6 + 5;int pr[1000005], mpr[1000005], dp[1000005], a[1000005],mpos[1000005];void solv(int m) //筛x的最小素因子{ int cnt = 0; for (int i = 2; i &lt;= m; i++) { if (!mpr[i]) pr[++cnt] = i, mpr[i] = i; for (int j = 1; j &lt;= cnt; j++) { if (pr[j] * i &gt; m||pr[j]&gt;mpr[i]) break; mpr[pr[j] * i] = pr[j]; } }}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n,m; cin &gt;&gt; n; m=~0x3f; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i],m=max(m,a[i]); solv(m); memset(dp,0x3f3f3f,sizeof dp); memset(mpos,0x3f3f3f3f,sizeof mpos); dp[0]=0; for(int i=1;i&lt;=n;i++) { int temp=a[i]; while(temp&gt;1) { int ans=mpr[temp]; //cout&lt;&lt;ans&lt;&lt;endl; mpos[ans]=min(mpos[ans],dp[i-1]);//得到当前最小素因子的最近位置 dp[i]=min(dp[i],mpos[ans]+1);//得到当前距离i的最小素因子的距离 temp/=ans; } } cout&lt;&lt;dp[n]&lt;&lt;endl;} leecode 版本: 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {int pr[1000005], mpr[1000005], dp[1000005], a[1000005],mpos[1000005];void solv(int m) //筛m以内所有数的最小素因子{ int cnt = 0; for (int i = 2; i &lt;= m; i++) { if (!mpr[i]) pr[++cnt] = i, mpr[i] = i; for (int j = 1; j &lt;= cnt; j++) { if (pr[j] * i &gt; m||pr[j]&gt;mpr[i]) break; mpr[pr[j] * i] = pr[j]; } }}public: int splitArray(vector&lt;int&gt;&amp; nums) { int n,m; n=nums.size(); m=~0x3f; for (int i = 0; i&lt;n; i++) a[i+1]=nums[i],m=max(m,a[i+1]); solv(m); memset(dp,0x3f3f3f,sizeof dp); memset(mpos,0x3f3f3f3f,sizeof mpos); dp[0]=0; for(int i=1;i&lt;=n;i++) { int temp=a[i]; while(temp&gt;1) { int ans=mpr[temp]; //cout&lt;&lt;ans&lt;&lt;endl; mpos[ans]=min(mpos[ans],dp[i-1]);//得到当前最小素因子的最近位置 dp[i]=min(dp[i],mpos[ans]+1);//得到当前距离i的最小素因子的距离 temp/=ans; } } return dp[n]; }};","link":"/2020/04/29/leetcode-%E5%88%87%E5%88%86%E6%95%B0%E7%BB%84/"},{"title":"文艺平衡树","text":"传送门：文艺平衡树首先要阐述一点，Fhq Treap的按大小分裂是支持区间操作的，而按值分裂是不支持区间操作的。Fhq Treap的分裂方式： 按权值分裂 按大小分裂 按权值分裂： 根据插入点的权值，将树按w为边界，分裂为两颗树，一颗树的权值大于w，一棵树的权值小于等于w，这样再把新节点合并进去，就可以维护树的平衡 按大小分裂： 根据插入点的节点大小，将树按big为边界，分裂为两颗树，一颗树的节点大小大于big，一棵树的节点大小小于等于big，这样再把新节点合并进去，不仅可以维护树的平衡，还支持区间操作 为什么按大小分裂会支持区间操作： 首先，新开的每一个节点，都可以用节点数量，代表区间中的一个端点，呢么我们如果修改区间，呢么我们只需要修改平衡树中节点数量在我们要修改的区间内即可，然后合并成新的平衡树即可，一颗平衡树的节点对应数量是一样的，我们只需要改变节点对应的值即可 该题思路： 利用支持区间修改的Fhq Treap，我们利用懒惰标记，对区间进行修改，交换当前区间的左右子树，从而达到颠倒一个区间 ：随机库函数，好多版本的C++不支持，所以就自己写一个叭 参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int base = 131;const int maxn = 1e5 + 5;//vector&lt;ll&gt; vec;//ll n, sum[maxn * 10], c[maxn * 10], a[maxn];//vector&lt;int&gt; vec;int su = 1;int rand(){ su = (su * base) % 1000007; return su;}int cnt, rt;struct node{ int ls, rs, w; int key, sizx; int lazy;} tr[maxn*50];int newnode(int w){ tr[++cnt].w = w, tr[cnt].sizx = 1; tr[cnt].lazy=0; tr[cnt].key = rand(); return cnt;}void pushup(int now){ tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1;}void pushdown(int now){ if (tr[now].lazy) { swap(tr[now].ls, tr[now].rs); tr[tr[now].ls].lazy ^= 1; tr[tr[now].rs].lazy ^= 1; tr[now].lazy = 0; }}void split(int now, int big, int &amp;x, int &amp;y){ if (!now) x = y = 0; else { pushdown(now); if (tr[tr[now].ls].sizx &lt; big) x = now, split(tr[now].rs, big - tr[tr[now].ls].sizx - 1, tr[now].rs, y); else y = now, split(tr[now].ls, big, x, tr[now].ls); pushup(now); }}int merge(int x, int y){ if (!x || !y) return x + y; if (tr[x].key &gt; tr[y].key) { pushdown(x); tr[x].rs = merge(tr[x].rs, y); pushup(x); return x; } else { pushdown(y); tr[y].ls = merge(x, tr[y].ls); pushup(y); return y; }}void reverse(int l, int r){ int x, y, z; split(rt, l-1, x, y); split(y, r - l + 1, y, z); tr[y].lazy ^= 1; rt = merge(merge(x, y), z);}void dfs(int now){ if (!now) return; pushdown(now); dfs(tr[now].ls); cout &lt;&lt; tr[now].w &lt;&lt; ' '; dfs(tr[now].rs);}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { rt = merge(rt, newnode(i)); } while (m--) { int ql, qr; cin &gt;&gt; ql &gt;&gt; qr; reverse(ql, qr); } dfs(rt); cout&lt;&lt;endl;}","link":"/2020/05/07/%E6%96%87%E8%89%BA%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"title":"线段树实现普通平衡树操作","text":"洛谷: 3369 (模板)普通平衡树题目描述:您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作: 1.插入 xx 数 2.删除 xx 数(若有多个相同的数，因只删除一个) 3.查询 xx 数的排名(排名定义为比当前数小的数的个数 +1+1 ) 4.查询排名为 xx 的数 5.求 xx 的前驱(前驱定义为小于 xx，且最大的数) 6.求 xx 的后继(后继定义为大于 xx，且最小的数) 输入格式第一行为 n，表示操作的个数,下面 n 行每行有两个数 opt 和 x，opt 表示操作的序号( 1&lt;=opt&lt;=6) 输出格式对于操作 3，4，5，6 每行输出一个数，表示对应答案 输入输出样例输入 #1 1234567891011101 1064654 11 3177211 4609291 6449851 841851 898516 819681 4927375 493598 输出 #1 12310646584185492737 数据范围 对于100%的数据，1&lt;=n&lt;=100000,|x|&lt;=10000000 思路: 用权值线段树，求整体区间的第k小，从而来实现1，2，4操作，然后利用前缀和的思路来求x的排名，从而实现3，5，6操作具体操作，参考以下代码 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 1e5 + 5;struct node{ int ls, rs, sum, lv, rv;} tr[maxn * 50];int cnt;void pushup(int k){ tr[k].sum = tr[tr[k].ls].sum + tr[tr[k].rs].sum;}void inser(int &amp;k, int L, int R, int pos, int w){ if (!k) k = ++cnt; if (L == R) { tr[k].sum += w; return; } int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[k].ls, L, mid, pos, w); else inser(tr[k].rs, mid + 1, R, pos, w); pushup(k);}int asik(int k, int L, int R, int ik){ if (L == R) return L; int mid = L + R &gt;&gt; 1; if (tr[tr[k].ls].sum &gt;= ik) return asik(tr[k].ls, L, mid, ik); else return asik(tr[k].rs, mid + 1, R, ik - tr[tr[k].ls].sum);}int ask(int k, int L, int R, int ql, int qr){ if (L &gt;= ql &amp;&amp; R &lt;= qr) { return tr[k].sum; } int mid = L + R &gt;&gt; 1; int ans = 0; if (ql &lt;= mid) ans += ask(tr[k].ls, L, mid, ql, qr); if (qr &gt; mid) ans += ask(tr[k].rs, mid + 1, R, ql, qr); return ans;}map&lt;int,int&gt;mp;int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, k = 0; cin &gt;&gt; n; while (n--) { int op, x; cin &gt;&gt; op &gt;&gt; x; if (op == 1) inser(k, -inf, inf, x, 1),mp[x]++; if (op == 2) inser(k, -inf, inf, x, -1),mp[x]--; if (op == 3) { inser(k, -inf, inf, x, 1),mp[x]++; int l = asik(k, -inf, inf, 1); cout &lt;&lt; ask(k, -inf, inf, l, x)-mp[x]+1&lt;&lt; endl; inser(k,-inf,inf,x,-1),mp[x]--; } if (op == 4) { cout &lt;&lt; asik(k, -inf, inf, x) &lt;&lt; endl; } if (op == 5) { inser(k, -inf, inf, x, 1),mp[x]++; int l = asik(k, -inf, inf, 1); int ans = ask(k, -inf, inf, l, x); cout &lt;&lt; asik(k, -inf, inf, ans - mp[x]) &lt;&lt; endl; inser(k, -inf, inf, x, -1),mp[x]--; } if (op == 6) { inser(k, -inf, inf, x, 1); int l = asik(k, -inf, inf, 1); int ans = ask(k, -inf, inf, l, x); cout &lt;&lt; asik(k, -inf, inf, ans+1) &lt;&lt; endl; inser(k, -inf, inf, x, -1); } }}","link":"/2020/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AE%9E%E7%8E%B0%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%93%8D%E4%BD%9C/"},{"title":"替罪羊树模板","text":"替罪羊树入门:以洛谷模板题为例:普通平衡树 这题正解是替罪羊树，呢么什么是替罪羊树？替罪羊树其实就是一颗平衡树，但是我们要如何去维护树的平衡呢？俗话说，暴力即优雅，替罪羊树，是通过重新构造不平衡的子树来进行维护树的平衡的替罪羊树的部分: 插入操作:插入节点((检查树的平衡(不平衡，则重构树(中序遍历，分治重构树，)，更新树的节点信息))) 删除操作:删除节点((检查树的平衡(不平衡，则重构树(中序遍历，分治重构树，)，更新树的节点信息))) 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 1e6 + 5;vector&lt;int&gt; vec;struct node{ int ls, rs, w; bool exist; int sizx, fact;} tr[maxn];int cnt, root;void pushup(int now)//维护节点信息{ tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1; tr[now].fact = tr[tr[now].ls].fact + tr[tr[now].rs].fact + 1;}void newnode(int &amp;now, int w)//开新点{ now = ++cnt; tr[now].w = w, tr[now].sizx = tr[now].fact = 1; tr[now].exist = true;}bool judge(int now) //判断是否平衡{ if (max(tr[tr[now].ls].sizx, tr[tr[now].rs].sizx) &gt; tr[now].sizx * 0.75) return true; if ((tr[now].sizx - tr[now].fact) &gt; tr[now].sizx * 0.3) return true; return false;}void mds(int now)//中序遍历{ if (!now) return; mds(tr[now].ls); if (tr[now].exist) vec.push_back(now); mds(tr[now].rs);}void cre(int L, int R, int &amp;now)//构造标准平衡树{ if (L == R) { now = vec[L]; tr[now].ls = tr[now].rs = 0; tr[now].sizx = tr[now].fact = 1; return; } int mid = L + R &gt;&gt; 1; while (L &lt; mid &amp;&amp; tr[vec[mid]].w == tr[vec[mid - 1]].w) mid--; now = vec[mid]; if (L &lt; mid) cre(L, mid - 1, tr[now].ls); else tr[now].ls=0; cre(mid + 1, R, tr[now].rs); pushup(now);}void update(int now, int en)//维护父辈节点{ if (!now) return; if (tr[now].w &gt; tr[en].w) update(tr[now].ls, en); else update(tr[now].rs, en); tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1;}void rebuild(int &amp;now)//重构树{ vec.clear(); mds(now); if (vec.empty()) { now = 0; return; } cre(0, vec.size() - 1, now);}void check(int &amp;now, int en) //检查，并重构子树{ if (now == en) return; if (judge(now)) { rebuild(now); update(root, now); return; } if (tr[en].w &lt; tr[now].w) check(tr[now].ls, en); else check(tr[now].rs, en);}void inser(int &amp;now, int w)//插入{ if (!now) { newnode(now, w); check(root, now); return; } tr[now].sizx++, tr[now].fact++; if (w &lt; tr[now].w) inser(tr[now].ls, w); else inser(tr[now].rs, w);}void del(int now, int w)//删除{ if (tr[now].exist &amp;&amp; tr[now].w == w) { tr[now].exist = false; tr[now].fact--; check(root, now); return; } tr[now].fact--; if (w &lt; tr[now].w) del(tr[now].ls, w); else del(tr[now].rs, w);}int getrank(int w)//求w的排名{ int now = root, rank = 1; while (now) { if (w &lt;= tr[now].w) now = tr[now].ls; else { rank += tr[now].exist + tr[tr[now].ls].fact,now = tr[now].rs; } } return rank;}int getnum(int rank)//求排名为rank的树数{ int now = root; while (now) { if (tr[now].exist&amp;&amp;tr[tr[now].ls].fact + tr[now].exist == rank) break; else if (rank &lt;= tr[tr[now].ls].fact) now = tr[now].ls; else { rank-=tr[now].exist + tr[tr[now].ls].fact,now=tr[now].rs; } } return tr[now].w;}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n; cin&gt;&gt;n; while(n--) { int op,x; cin&gt;&gt;op&gt;&gt;x; switch(op) { case 1: inser(root,x); break; case 2: del(root,x); break; case 3: cout&lt;&lt;getrank(x)&lt;&lt;endl; break; case 4: cout&lt;&lt;getnum(x)&lt;&lt;endl; break; case 5: cout&lt;&lt;getnum(getrank(x)-1)&lt;&lt;endl; break; case 6: cout&lt;&lt;getnum(getrank(x+1))&lt;&lt;endl; break; } }}","link":"/2020/05/01/%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91%E6%A8%A1%E6%9D%BF/"},{"title":"浅谈主席树","text":"主席树 我学习主席树，其实已经好几个月了，但是一直没有理解透彻，只能看着板子敲，今天有回顾了一下主席树，然后就突然有了新的理解。 主席树学习的前置技能 权值线段树 动态开点 权值线段树 学习权值线段树后，会了解求整体区间第k小，这个操作和主席树模板题中的求区间第k小操作是一样的 动态开点 首先主席树其实是一颗残树，但一般的线段树其实是预处理整个区间，所以一般建线段树的方法，并不适合建主席树，相反动态开点建树的方法，是可以在树的任何一个分支去建一条链的，原因在于，动态开点其实是给你一棵虚拟的树，我们按照我们要插入树中值的大小，在树中对应的位置，然后递归寻找这个位置，在找的过程中，把经过的点开出来，而且动态开点无需考虑数的大小，只需考虑数量 主席树 主席树其实的思想其实就是权值线段树，权值线段树可以求整体区间的第k小，原因在于，我们已知整体区间中不同区间的数的个数，呢么主席树因为有动态开点和权值线段树加持，我们可以，用动态开点建立n个版本的残缺线段树，如果我们要询问区间的第k小，我们就可以在l-r版本的残缺线段树中进行，权值线段树的操作，这点和前缀和思路一样 模板题 参考代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 2e5 + 5;int rt[maxn], cnt;struct node{ int ls, rs, sum;} tr[maxn * 40];void inser(int ver, int &amp;now, int L, int R, int pos){ now = ++cnt; tr[now] = tr[ver]; tr[now].sum++; if (L == R) return; int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[ver].ls, tr[now].ls, L, mid, pos); else inser(tr[ver].rs, tr[now].rs, mid + 1, R, pos);}int ask(int ver, int now, int L, int R, int pos){ if (L == R) return L; int mid = L + R &gt;&gt; 1; int sum = tr[tr[now].ls].sum - tr[tr[ver].ls].sum; if (sum &gt;= pos) return ask(tr[ver].ls, tr[now].ls, L, mid, pos); else return ask(tr[ver].rs, tr[now].rs, mid + 1, R, pos - sum);}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, x, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; x, inser(rt[i - 1], rt[i], -inf, inf, x); while (q--) { int ql, qr, ik; cin &gt;&gt; ql &gt;&gt; qr &gt;&gt; ik; cout &lt;&lt; ask(rt[ql - 1], rt[qr], -inf, inf, ik) &lt;&lt; endl; }}","link":"/2020/04/24/%E6%B5%85%E8%B0%88%E4%B8%BB%E5%B8%AD%E6%A0%91/"},{"title":"洛谷 P4309 最长上升子序列（平衡树维护）","text":"传送门： 题目描述 给定一个序列，初始为空。现在我们将1到N的数字插入到序列中，每次将一个数字插入到一个特定的位置。每插入一个数字，我们都想知道此时最长上升子序列长度是多少？ 输入格式 第一行一个整数N，表示我们要将1到N插入序列中。接下是N个数字，第k个数字Xk，表示我们将k插入到位置Xk。（0&lt;=Xk&lt;=k-1,1&lt;=k&lt;=N） 输出格式 N行，第i行表示i插入Xi位置后序列的最长上升子序列的长度是多少。 输入输出样例 输入#1： 1230 0 2 输出#1： 123112 思路：这题由于题目的独特性，最长子序列中的数都没有重复的，而且每次插入的值都会保证是最大的，所以我们插入新值时，我们遍可以获得当前位置的最长上升子序列的长度为：分裂出(小于当前位置的子树)的最长上升子序列+1然后我们再合并回整个平衡树，并且再合并的时候，不断维护，即可得到整体区间的最大上升子序列长度。动态转移方程：tr[now].w = max(dp[tr[now].pos], max(tr[tr[now].ls].w, tr[tr[now].rs].w)); 参考代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;typedef long long ll;const int inf = 1 &lt;&lt; 30;const int maxn = 2e5 + 5;const int N = 1e3 + 5;const int base = 131;struct node{ int ls, rs, sizx, w, key, pos;} tr[maxn];int cnt, rt, dp[maxn], su = 1;int rand(){ su = (su * base) % 100007; return su;}int newnode(int w, int i){ tr[++cnt].sizx = 1, tr[cnt].w = w; tr[cnt].key = rand(), tr[cnt].pos = i, dp[i] = w; return cnt;}void pushup(int now){ tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1; tr[now].w = max(dp[tr[now].pos], max(tr[tr[now].ls].w, tr[tr[now].rs].w));}void split(int now, int big, int &amp;x, int &amp;y){ if (!now) x = y = 0; else { if (big &lt;= tr[tr[now].ls].sizx) y = now, split(tr[now].ls, big, x, tr[now].ls); else x = now, split(tr[now].rs, big - 1 - tr[tr[now].ls].sizx, tr[now].rs, y); pushup(now); }}int merge(int x, int y){ if (!x || !y) return x + y; else { if(tr[x].key&gt;tr[y].key) { tr[x].rs=merge(tr[x].rs,y); pushup(x); return x; } else { tr[y].ls=merge(x,tr[y].ls); pushup(y); return y; } }}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n,big; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) { cin&gt;&gt;big; int x,y,z; split(rt,big,x,y); rt=merge(merge(x,newnode(tr[x].w+1,i)),y); cout&lt;&lt;tr[rt].w&lt;&lt;endl; }}","link":"/2020/05/16/%E6%B4%9B%E8%B0%B7-P4309-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E5%B9%B3%E8%A1%A1%E6%A0%91%E7%BB%B4%E6%8A%A4%EF%BC%89/"}],"tags":[{"name":"ACM算法","slug":"ACM算法","link":"/tags/ACM%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"}],"categories":[]}