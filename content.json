{"pages":[],"posts":[{"title":"O(n)哈希检验求最长回文子串","text":"求最长回文子串，大家公认的算法是Manacher，但是如果我们不想学习Mangacher，又想在 O(n) 的时间复杂度下解决该问题怎么办？ 哈希算法可以帮我们做到，而且容易理解，代码还很短 举个栗子现在有字符串 str=&quot;cbaaab&quot;，我们要求它的回文子串，那么该怎么办呢？这里我们借用Manacher算法里的一个思想，向原字符串里插字符，使得这个字符串为奇数个，这样方便我们统一处理。我们在这个栗子中插入'#' 原字符:c b a a a b现字符:# c # b # a # a # a # b # 接下来: 先求出现字符串的正哈希 在求出现字符串的逆哈希 定义最长回文串半径 枚举字符串中的点 检验当前点的正哈希[i-l,i] 和 [i+l,i]是否相同 若相同扩大半径，反则退出循环 更新最大回文半径，记录ans 输出ans-1即可 推荐题目: 回文子串的最大长度 参考代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int inf = 1 &lt;&lt; 30;const int maxn = 2e6 + 5;typedef long long ll;//const int N = 5005;char s[maxn], str[maxn];typedef unsigned long long ull;ull h1[maxn], h2[maxn], p[maxn];int main(){ ios::sync_with_stdio(false); cin.tie(0); int id = 0; while (cin &gt;&gt; (s + 1) &amp;&amp; s[1] != 'E') { int n = strlen(s + 1); int t = 0; for (int i = 1; i &lt;= n; i++) { str[++t] = 'z'; str[++t] = s[i]; } str[++t] = 'z'; p[0] = 1ull; for (int i = 1; i &lt;= t; i++) { h1[i] = h1[i - 1] * 131ull + str[i] - 'a' + 1ull; h2[t - i + 1] = h2[t - i + 2] * 131ull + str[t - i + 1] - 'a' + 1ull; p[i] = p[i - 1] * 131ull; } int l, ans = 0, j = 0; for (int i = 1; i &lt;= t; i++) { l = ans; bool fla = false; while (h1[i] - h1[i - l] * p[l] == h2[i] - h2[i + l] * p[l] &amp;&amp; i + l &lt;= t &amp;&amp; i - l &gt;= 1) l++, fla = true; if (fla &amp;&amp; i + l &lt;= t &amp;&amp; i - l &gt;= 1) --l; ans = max(l, ans); } cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++id &lt;&lt; &quot;: &quot; &lt;&lt; ans - 1 &lt;&lt; endl; }}","link":"/2020/04/19/O-n-%E5%93%88%E5%B8%8C%E6%A3%80%E9%AA%8C%E6%B1%82%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"title":"HDU 3282 动态开点+区间第k小","text":"题意: 给n个数，把这n个数以此插入容器中，当插入的数量是奇数个时输出中位数 样例: Sample Input31 91 2 3 4 5 6 7 8 92 99 8 7 6 5 4 3 2 13 2323 41 13 22 -3 24 -31 -11 -8 -73 5 103 211 -311 -45 -67 -73 -81 -99-33 24 56 Sample Output1 51 2 3 4 52 59 8 7 6 53 1223 23 22 22 13 3 5 5 3 -3-7 -3 吐槽: 今天有点事，没看来得及看这道题，其实就是询问整体区间第k小的板题 思路: 我没怎么看数据范围，直接用动态开点线段树写了，当然这题数据范围很小，普通线段树也可以写，因为数据范围并不是很大，如果数据范围给到1e9，那也只能动态开点或者离散化写了，这题主要考察权值线段树，我们可以统计权值，我们询问的值如果小于等于左儿子节点的权值，呢么我们询问的值一定在左边，我们向左递归，反之减去左边权值向右递归 参考代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int inf = 1 &lt;&lt; 30;const int maxn = 1e6 + 5;typedef long long ll;const int N = 1005;typedef unsigned long long ull;//char s[maxn], str[maxn], s3[maxn];//char s[N][N];//ll da[maxn], dab[maxn], daba[maxn], sum[maxn];int a[maxn];struct node{ int ls, rs, sum;} tr[maxn &lt;&lt; 1];int cnt;void inser(int &amp;k, int L, int R, int pos){ if (!k) k = ++cnt; tr[k].sum++; if (L == R) { return; } int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[k].ls, L, mid, pos); else inser(tr[k].rs, mid + 1, R, pos);}int ask(int k, int L, int R, int ik){ if (L == R) { return L; } int mid = L + R &gt;&gt; 1; int sum = tr[tr[k].ls].sum; if (sum &gt;= ik) return ask(tr[k].ls, L, mid, ik); else return ask(tr[k].rs, mid + 1, R, ik - sum);}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, m, k; int t; cin &gt;&gt; t; while (t--) { memset(a, 0, sizeof a); memset(tr, 0, sizeof(tr)); cin &gt;&gt; m &gt;&gt; n; k = cnt = 0; int x, id = 0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; inser(k, -inf, inf, x); if (i &amp; 1) { int pos = (1 + i) / 2; a[id++] = ask(k, -inf, inf, pos); } } cout &lt;&lt; m &lt;&lt; ' ' &lt;&lt; (n + 1) / 2 ; for (int i = 0; i &lt;id; i++) { if (i % 10 == 0) cout &lt;&lt; endl; if (i % 10 == 0) cout &lt;&lt; a[i]; else cout &lt;&lt; ' ' &lt;&lt; a[i]; } cout&lt;&lt;endl; }}","link":"/2020/04/19/HDU-3282-%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9-%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%B0%8F/"},{"title":"ABA的个数","text":"题意: 给一个只包含大写字母的字符串，求其中有多少个ABA(不一定连续)举个栗子: ABBBA 这个样例有3个ABA 样例: 输入: YARBRBAQTYAYBATTBLBZA 输出 26 思路:可以先把字符串中的A B取出，按原序放到一个新数组str[ ]中，然后依次预处理，A的数量，AB的数量，ABA的数量，我们可以开三个数组来处理他们，da[ ]，dab[]，daba[]，最终存ABA数量的数组可以由之前两个推出 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int inf = 1 &lt;&lt; 30;const int maxn = 1e6 + 5;typedef long long ll;//const int N = 5005;typedef unsigned long long ull;char s[maxn], str[maxn];ll da[maxn], dab[maxn], daba[maxn];int main(){ ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; s + 1; ll n = strlen(s + 1); ll cnt = 0; for (int i = 1; i &lt;= n; i++) { if (s[i] == 'A' || s[i] == 'B') str[++cnt] = s[i]; } for (int i = 1; i &lt;= cnt; i++) { if (str[i] == 'A') da[i] = da[i - 1] + 1; else da[i] = da[i - 1]; } for (int i = 1; i &lt;= cnt; i++) { if (str[i] == 'B') dab[i] = dab[i - 1] + da[i]; else dab[i] = dab[i - 1]; } for (int i = 1; i &lt;= cnt; i++) { if (str[i] == 'A') daba[i] = daba[i - 1] + dab[i]; else daba[i] = daba[i - 1]; } cout&lt;&lt;daba[cnt]&lt;&lt;endl;}","link":"/2020/04/19/ABA%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"我的第一篇博客","text":"Hexo 常用命令详解1:hexo inithexo init 命令用于初始化本地文件夹为网站的根目录 $ hexo init [folder] folder 可选参数, 可以指定初始化目录的路径, 若无指定则默认当前目录 2:hexo newhexo new 命令用于新建文章, 一般可以简写为 hexo n$ hexo new [layout] &lt;title&gt; layout 可选参数, 用以指定文章类型, 若无指定则默认由配置文件中的 default_layout选项决定 title 必填参数，可以用以指定文章标题，如果参数中含有空格，则需要使用双引号包围 3:hexo generatehexo generate 命令用于生成静态文件, 一般可以简写为hexo g$ hexo generate*-d 选项, 指定生成后部署，与hexo d -g等价 4:hexo serverhexo server 命令用于启动本地服务器, 一般可以简写为hexo s$ hexo server -p选项，指定服务器端口, 默认为 4000 -i选项，指定服务器 IP 地址, 默认为 0.0.0.0 -s选项, 静态模式 , 仅提供 public 文件夹中的文件并禁用文件监视 说明: 运行服务器前需要安装 hexo-server 插件$ npm install hexo-server --save 5:hexo deployhexo deploy 命令用于部署网站, 一般可以简写为 hexo d $ hexo deploy 6:hexo cleanhexo clean 命令用于清理缓存文件, 是一个比较常用的命令网站显示异常时可尝试此操作 7: Option(1) hexo –safehexo --safe 表示安全模式, 用于禁用加载插件和脚本$ hexo --safe安装新插件时遇到问题可尝试此操作(2) hexo –debughexo --debug 表示调试模式, 用于将消息详细记录到终端和debug.log文件(3)hexo –silenthexo --silent 表示静默模式, 用于静默输出到终端$ hexo --silent","link":"/2020/04/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"替罪羊树模板","text":"替罪羊树入门:以洛谷模板题为例:普通平衡树 这题正解是替罪羊树，呢么什么是替罪羊树？替罪羊树其实就是一颗平衡树，但是我们要如何去维护树的平衡呢？俗话说，暴力即优雅，替罪羊树，是通过重新构造不平衡的子树来进行维护树的平衡的替罪羊树的部分: 插入操作:插入节点((检查树的平衡(不平衡，则重构树(中序遍历，分治重构树，)，更新树的节点信息))) 删除操作:删除节点((检查树的平衡(不平衡，则重构树(中序遍历，分治重构树，)，更新树的节点信息))) 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 1e6 + 5;vector&lt;int&gt; vec;struct node{ int ls, rs, w; bool exist; int sizx, fact;} tr[maxn];int cnt, root;void pushup(int now)//维护节点信息{ tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1; tr[now].fact = tr[tr[now].ls].fact + tr[tr[now].rs].fact + 1;}void newnode(int &amp;now, int w)//开新点{ now = ++cnt; tr[now].w = w, tr[now].sizx = tr[now].fact = 1; tr[now].exist = true;}bool judge(int now) //判断是否平衡{ if (max(tr[tr[now].ls].sizx, tr[tr[now].rs].sizx) &gt; tr[now].sizx * 0.75) return true; if ((tr[now].sizx - tr[now].fact) &gt; tr[now].sizx * 0.3) return true; return false;}void mds(int now)//中序遍历{ if (!now) return; mds(tr[now].ls); if (tr[now].exist) vec.push_back(now); mds(tr[now].rs);}void cre(int L, int R, int &amp;now)//构造标准平衡树{ if (L == R) { now = vec[L]; tr[now].ls = tr[now].rs = 0; tr[now].sizx = tr[now].fact = 1; return; } int mid = L + R &gt;&gt; 1; while (L &lt; mid &amp;&amp; tr[vec[mid]].w == tr[vec[mid - 1]].w) mid--; now = vec[mid]; if (L &lt; mid) cre(L, mid - 1, tr[now].ls); else tr[now].ls=0; cre(mid + 1, R, tr[now].rs); pushup(now);}void update(int now, int en)//维护父辈节点{ if (!now) return; if (tr[now].w &gt; tr[en].w) update(tr[now].ls, en); else update(tr[now].rs, en); tr[now].sizx = tr[tr[now].ls].sizx + tr[tr[now].rs].sizx + 1;}void rebuild(int &amp;now)//重构树{ vec.clear(); mds(now); if (vec.empty()) { now = 0; return; } cre(0, vec.size() - 1, now);}void check(int &amp;now, int en) //检查，并重构子树{ if (now == en) return; if (judge(now)) { rebuild(now); update(root, now); return; } if (tr[en].w &lt; tr[now].w) check(tr[now].ls, en); else check(tr[now].rs, en);}void inser(int &amp;now, int w)//插入{ if (!now) { newnode(now, w); check(root, now); return; } tr[now].sizx++, tr[now].fact++; if (w &lt; tr[now].w) inser(tr[now].ls, w); else inser(tr[now].rs, w);}void del(int now, int w)//删除{ if (tr[now].exist &amp;&amp; tr[now].w == w) { tr[now].exist = false; tr[now].fact--; check(root, now); return; } tr[now].fact--; if (w &lt; tr[now].w) del(tr[now].ls, w); else del(tr[now].rs, w);}int getrank(int w)//求w的排名{ int now = root, rank = 1; while (now) { if (w &lt;= tr[now].w) now = tr[now].ls; else { rank += tr[now].exist + tr[tr[now].ls].fact,now = tr[now].rs; } } return rank;}int getnum(int rank)//求排名为rank的树数{ int now = root; while (now) { if (tr[now].exist&amp;&amp;tr[tr[now].ls].fact + tr[now].exist == rank) break; else if (rank &lt;= tr[tr[now].ls].fact) now = tr[now].ls; else { rank-=tr[now].exist + tr[tr[now].ls].fact,now=tr[now].rs; } } return tr[now].w;}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n; cin&gt;&gt;n; while(n--) { int op,x; cin&gt;&gt;op&gt;&gt;x; switch(op) { case 1: inser(root,x); break; case 2: del(root,x); break; case 3: cout&lt;&lt;getrank(x)&lt;&lt;endl; break; case 4: cout&lt;&lt;getnum(x)&lt;&lt;endl; break; case 5: cout&lt;&lt;getnum(getrank(x)-1)&lt;&lt;endl; break; case 6: cout&lt;&lt;getnum(getrank(x+1))&lt;&lt;endl; break; } }}","link":"/2020/05/01/%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91%E6%A8%A1%E6%9D%BF/"},{"title":"leecode 切分数组","text":"dp + 筛最小素因子 + 枚举最小素因子切分数组: 给定一个整数数组 nums ，小李想将 nums 切割成若干个非空子数组，使得每个子数组最左边的数和最右边的数的最大公约数大于 1 。为了减少他的工作量，请求出最少可以切成多少个子数组。示例 1：输入：nums = [2,3,3,2,3,3]输出：2解释：最优切割为 [2,3,3,2] 和 [3,3] 。第一个子数组头尾数字的最大公约数为 2 ，第二个子数组头尾数字的最大公约数为 3 。示例 2：输入：nums = [2,3,5,7]输出：4解释：只有一种可行的切割：[2], [3], [5], [7] 限制： 1 &lt;= nums.length &lt;= 10^5 2 &lt;= nums[i] &lt;= 10^6 思路: 首先我们先筛出最大数据以内(包括最大数据)所有数对应的最小素因子 推导dp方程 1:当前i位置所对应的数的组数 = min(当前i位置对应的最小素因子的位置,dp[i]+1)2:当前i位置对应的最小素因子的位置= min(min[a[i]]，dp[i-1]) 枚举每个数的最小的最小素因子所对应的位置 因为当前数可能有好多素因子，所以我们把他除以他的最小素因子，呢么得到的数就会对应本身的最小素因子 参考代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 1e6 + 5;int pr[1000005], mpr[1000005], dp[1000005], a[1000005],mpos[1000005];void solv(int m) //筛x的最小素因子{ int cnt = 0; for (int i = 2; i &lt;= m; i++) { if (!mpr[i]) pr[++cnt] = i, mpr[i] = i; for (int j = 1; j &lt;= cnt; j++) { if (pr[j] * i &gt; m||pr[j]&gt;mpr[i]) break; mpr[pr[j] * i] = pr[j]; } }}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n,m; cin &gt;&gt; n; m=~0x3f; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; a[i],m=max(m,a[i]); solv(m); memset(dp,0x3f3f3f,sizeof dp); memset(mpos,0x3f3f3f3f,sizeof mpos); dp[0]=0; for(int i=1;i&lt;=n;i++) { int temp=a[i]; while(temp&gt;1) { int ans=mpr[temp]; //cout&lt;&lt;ans&lt;&lt;endl; mpos[ans]=min(mpos[ans],dp[i-1]);//得到当前最小素因子的最近位置 dp[i]=min(dp[i],mpos[ans]+1);//得到当前距离i的最小素因子的距离 temp/=ans; } } cout&lt;&lt;dp[n]&lt;&lt;endl;} leecode 版本: 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {int pr[1000005], mpr[1000005], dp[1000005], a[1000005],mpos[1000005];void solv(int m) //筛m以内所有数的最小素因子{ int cnt = 0; for (int i = 2; i &lt;= m; i++) { if (!mpr[i]) pr[++cnt] = i, mpr[i] = i; for (int j = 1; j &lt;= cnt; j++) { if (pr[j] * i &gt; m||pr[j]&gt;mpr[i]) break; mpr[pr[j] * i] = pr[j]; } }}public: int splitArray(vector&lt;int&gt;&amp; nums) { int n,m; n=nums.size(); m=~0x3f; for (int i = 0; i&lt;n; i++) a[i+1]=nums[i],m=max(m,a[i+1]); solv(m); memset(dp,0x3f3f3f,sizeof dp); memset(mpos,0x3f3f3f3f,sizeof mpos); dp[0]=0; for(int i=1;i&lt;=n;i++) { int temp=a[i]; while(temp&gt;1) { int ans=mpr[temp]; //cout&lt;&lt;ans&lt;&lt;endl; mpos[ans]=min(mpos[ans],dp[i-1]);//得到当前最小素因子的最近位置 dp[i]=min(dp[i],mpos[ans]+1);//得到当前距离i的最小素因子的距离 temp/=ans; } } return dp[n]; }};","link":"/2020/04/29/leecode-%E5%88%87%E5%88%86%E6%95%B0%E7%BB%84/"},{"title":"可持久化数组","text":"可持久化数组 可持久化数组其实就是保存了历史版本的数组。对于历史版本，我们需要开一个rt[ ]来保存，当前版本的根节点，我们通过根节点的索引，可以，找到当前版本的树中，所携带rt[0]-rt[i]这个区间，的任意点的信息。 题目描述 如题，你需要维护这样的一个长度为 NN 的数组，支持如下几种操作，在某个历史版本上修改某一个位置上的值，访问某个历史版本上的某一位置的值，此外，每进行一次操作（对于操作2，即为生成一个完全一样的版本，不作任何改动），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组） 输入格式 输入的第一行包含两个正整数 N, MN,M， 分别表示数组的长度和操作的个数。第二行包含NN个整数，依次为初始状态下数组各位的值（依次为 ai，1≤i≤N）接下来MM行每行包含3或4个整数，代表两种操作之一（ii为基于的历史版本号）： 1:对于操作1，格式为v 1 loc value ，即为在版本v的基础上，将 loc位置的值修改为 value​ 2:对于操作2，格式为v 1 loc ，即为在版本v的基础上，询问loc位置的值 输出格式 输出包含若干行，依次为每个操作2的结果。 输入输出样例 输入 10123456789101159 46 14 87 410 2 10 1 1 140 1 1 570 1 1 884 2 40 2 50 2 44 2 12 2 21 1 5 91 输出 123456598741878846 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 1e6 + 5;struct node{ int ls, rs, w;} tr[maxn * 32];int a[maxn], rt[maxn], cnt;void inser(int ver, int &amp;now, int L, int R, int pos, int w){ now = ++cnt; tr[now] = tr[ver]; if (L == R) { tr[now].w = w; return; } int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[ver].ls, tr[now].ls, L, mid, pos, w); else inser(tr[ver].rs, tr[now].rs, mid + 1, R, pos, w);}int ask(int now, int L, int R, int pos){ if (L == R) return tr[now].w; int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) return ask(tr[now].ls, L, mid, pos); else return ask(tr[now].rs, mid + 1, R, pos);}int main(){ int n, m, x; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;x), inser(rt[0], rt[0], 1, n, i, x); for (int i = 1; i &lt;= m; i++) { int ba, op, pos, w; scanf(&quot;%d %d&quot;, &amp;ba, &amp;op); if (op == 1) { scanf(&quot;%d %d&quot;, &amp;pos, &amp;w); inser(rt[ba], rt[i], 1, n, pos, w); } else { scanf(&quot;%d&quot;, &amp;pos); int ans = ask(rt[ba], 1, n, pos); printf(&quot;%d\\n&quot;, ans); rt[i] = rt[ba]; } }}","link":"/2020/04/24/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E7%BB%84/"},{"title":"线段树实现普通平衡树操作","text":"洛谷: 3369 (模板)普通平衡树题目描述:您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作: 1.插入 xx 数 2.删除 xx 数(若有多个相同的数，因只删除一个) 3.查询 xx 数的排名(排名定义为比当前数小的数的个数 +1+1 ) 4.查询排名为 xx 的数 5.求 xx 的前驱(前驱定义为小于 xx，且最大的数) 6.求 xx 的后继(后继定义为大于 xx，且最小的数) 输入格式第一行为 n，表示操作的个数,下面 n 行每行有两个数 opt 和 x，opt 表示操作的序号( 1&lt;=opt&lt;=6) 输出格式对于操作 3，4，5，6 每行输出一个数，表示对应答案 输入输出样例输入 #1 1234567891011101 1064654 11 3177211 4609291 6449851 841851 898516 819681 4927375 493598 输出 #1 12310646584185492737 数据范围 对于100%的数据，1&lt;=n&lt;=100000,|x|&lt;=10000000 思路: 用权值线段树，求整体区间的第k小，从而来实现1，2，4操作，然后利用前缀和的思路来求x的排名，从而实现3，5，6操作具体操作，参考以下代码 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 1e5 + 5;struct node{ int ls, rs, sum, lv, rv;} tr[maxn * 50];int cnt;void pushup(int k){ tr[k].sum = tr[tr[k].ls].sum + tr[tr[k].rs].sum;}void inser(int &amp;k, int L, int R, int pos, int w){ if (!k) k = ++cnt; if (L == R) { tr[k].sum += w; return; } int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[k].ls, L, mid, pos, w); else inser(tr[k].rs, mid + 1, R, pos, w); pushup(k);}int asik(int k, int L, int R, int ik){ if (L == R) return L; int mid = L + R &gt;&gt; 1; if (tr[tr[k].ls].sum &gt;= ik) return asik(tr[k].ls, L, mid, ik); else return asik(tr[k].rs, mid + 1, R, ik - tr[tr[k].ls].sum);}int ask(int k, int L, int R, int ql, int qr){ if (L &gt;= ql &amp;&amp; R &lt;= qr) { return tr[k].sum; } int mid = L + R &gt;&gt; 1; int ans = 0; if (ql &lt;= mid) ans += ask(tr[k].ls, L, mid, ql, qr); if (qr &gt; mid) ans += ask(tr[k].rs, mid + 1, R, ql, qr); return ans;}map&lt;int,int&gt;mp;int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, k = 0; cin &gt;&gt; n; while (n--) { int op, x; cin &gt;&gt; op &gt;&gt; x; if (op == 1) inser(k, -inf, inf, x, 1),mp[x]++; if (op == 2) inser(k, -inf, inf, x, -1),mp[x]--; if (op == 3) { inser(k, -inf, inf, x, 1),mp[x]++; int l = asik(k, -inf, inf, 1); cout &lt;&lt; ask(k, -inf, inf, l, x)-mp[x]+1&lt;&lt; endl; inser(k,-inf,inf,x,-1),mp[x]--; } if (op == 4) { cout &lt;&lt; asik(k, -inf, inf, x) &lt;&lt; endl; } if (op == 5) { inser(k, -inf, inf, x, 1),mp[x]++; int l = asik(k, -inf, inf, 1); int ans = ask(k, -inf, inf, l, x); cout &lt;&lt; asik(k, -inf, inf, ans - mp[x]) &lt;&lt; endl; inser(k, -inf, inf, x, -1),mp[x]--; } if (op == 6) { inser(k, -inf, inf, x, 1); int l = asik(k, -inf, inf, 1); int ans = ask(k, -inf, inf, l, x); cout &lt;&lt; asik(k, -inf, inf, ans+1) &lt;&lt; endl; inser(k, -inf, inf, x, -1); } }}","link":"/2020/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AE%9E%E7%8E%B0%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%93%8D%E4%BD%9C/"},{"title":"浅谈主席树","text":"主席树 我学习主席树，其实已经好几个月了，但是一直没有理解透彻，只能看着板子敲，今天有回顾了一下主席树，然后就突然有了新的理解。 主席树学习的前置技能 权值线段树 动态开点 权值线段树 学习权值线段树后，会了解求整体区间第k小，这个操作和主席树模板题中的求区间第k小操作是一样的 动态开点 首先主席树其实是一颗残树，但一般的线段树其实是预处理整个区间，所以一般建线段树的方法，并不适合建主席树，相反动态开点建树的方法，是可以在树的任何一个分支去建一条链的，原因在于，动态开点其实是给你一棵虚拟的树，我们按照我们要插入树中值的大小，在树中对应的位置，然后递归寻找这个位置，在找的过程中，把经过的点开出来，而且动态开点无需考虑数的大小，只需考虑数量 主席树 主席树其实的思想其实就是权值线段树，权值线段树可以求整体区间的第k小，原因在于，我们已知整体区间中不同区间的数的个数，呢么主席树因为有动态开点和权值线段树加持，我们可以，用动态开点建立n个版本的残缺线段树，如果我们要询问区间的第k小，我们就可以在l-r版本的残缺线段树中进行，权值线段树的操作，这点和前缀和思路一样 模板题 参考代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 2e5 + 5;int rt[maxn], cnt;struct node{ int ls, rs, sum;} tr[maxn * 40];void inser(int ver, int &amp;now, int L, int R, int pos){ now = ++cnt; tr[now] = tr[ver]; tr[now].sum++; if (L == R) return; int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[ver].ls, tr[now].ls, L, mid, pos); else inser(tr[ver].rs, tr[now].rs, mid + 1, R, pos);}int ask(int ver, int now, int L, int R, int pos){ if (L == R) return L; int mid = L + R &gt;&gt; 1; int sum = tr[tr[now].ls].sum - tr[tr[ver].ls].sum; if (sum &gt;= pos) return ask(tr[ver].ls, tr[now].ls, L, mid, pos); else return ask(tr[ver].rs, tr[now].rs, mid + 1, R, pos - sum);}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, x, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; x, inser(rt[i - 1], rt[i], -inf, inf, x); while (q--) { int ql, qr, ik; cin &gt;&gt; ql &gt;&gt; qr &gt;&gt; ik; cout &lt;&lt; ask(rt[ql - 1], rt[qr], -inf, inf, ik) &lt;&lt; endl; }}","link":"/2020/04/24/%E6%B5%85%E8%B0%88%E4%B8%BB%E5%B8%AD%E6%A0%91/"}],"tags":[{"name":"ACM算法","slug":"ACM算法","link":"/tags/ACM%E7%AE%97%E6%B3%95/"}],"categories":[]}