{"pages":[],"posts":[{"title":"O(n)哈希检验求最长回文子串","text":"求最长回文子串，大家公认的算法是Manacher，但是如果我们不想学习Mangacher，又想在 O(n) 的时间复杂度下解决该问题怎么办？ 哈希算法可以帮我们做到，而且容易理解，代码还很短 举个栗子现在有字符串 str=&quot;cbaaab&quot;，我们要求它的回文子串，那么该怎么办呢？这里我们借用Manacher算法里的一个思想，向原字符串里插字符，使得这个字符串为奇数个，这样方便我们统一处理。我们在这个栗子中插入'#' 原字符:c b a a a b现字符:# c # b # a # a # a # b # 接下来: 先求出现字符串的正哈希 在求出现字符串的逆哈希 定义最长回文串半径 枚举字符串中的点 检验当前点的正哈希[i-l,i] 和 [i+l,i]是否相同 若相同扩大半径，反则退出循环 更新最大回文半径，记录ans 输出ans-1即可 推荐题目: 回文子串的最大长度 参考代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int inf = 1 &lt;&lt; 30;const int maxn = 2e6 + 5;typedef long long ll;//const int N = 5005;char s[maxn], str[maxn];typedef unsigned long long ull;ull h1[maxn], h2[maxn], p[maxn];int main(){ ios::sync_with_stdio(false); cin.tie(0); int id = 0; while (cin &gt;&gt; (s + 1) &amp;&amp; s[1] != 'E') { int n = strlen(s + 1); int t = 0; for (int i = 1; i &lt;= n; i++) { str[++t] = 'z'; str[++t] = s[i]; } str[++t] = 'z'; p[0] = 1ull; for (int i = 1; i &lt;= t; i++) { h1[i] = h1[i - 1] * 131ull + str[i] - 'a' + 1ull; h2[t - i + 1] = h2[t - i + 2] * 131ull + str[t - i + 1] - 'a' + 1ull; p[i] = p[i - 1] * 131ull; } int l, ans = 0, j = 0; for (int i = 1; i &lt;= t; i++) { l = ans; bool fla = false; while (h1[i] - h1[i - l] * p[l] == h2[i] - h2[i + l] * p[l] &amp;&amp; i + l &lt;= t &amp;&amp; i - l &gt;= 1) l++, fla = true; if (fla &amp;&amp; i + l &lt;= t &amp;&amp; i - l &gt;= 1) --l; ans = max(l, ans); } cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++id &lt;&lt; &quot;: &quot; &lt;&lt; ans - 1 &lt;&lt; endl; }}","link":"/2020/04/19/O-n-%E5%93%88%E5%B8%8C%E6%A3%80%E9%AA%8C%E6%B1%82%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"title":"我的第一篇博客","text":"Hexo 常用命令详解1:hexo inithexo init 命令用于初始化本地文件夹为网站的根目录 $ hexo init [folder] folder 可选参数, 可以指定初始化目录的路径, 若无指定则默认当前目录 2:hexo newhexo new 命令用于新建文章, 一般可以简写为 hexo n$ hexo new [layout] &lt;title&gt; layout 可选参数, 用以指定文章类型, 若无指定则默认由配置文件中的 default_layout选项决定 title 必填参数，可以用以指定文章标题，如果参数中含有空格，则需要使用双引号包围 3:hexo generatehexo generate 命令用于生成静态文件, 一般可以简写为hexo g$ hexo generate*-d 选项, 指定生成后部署，与hexo d -g等价 4:hexo serverhexo server 命令用于启动本地服务器, 一般可以简写为hexo s$ hexo server -p选项，指定服务器端口, 默认为 4000 -i选项，指定服务器 IP 地址, 默认为 0.0.0.0 -s选项, 静态模式 , 仅提供 public 文件夹中的文件并禁用文件监视 说明: 运行服务器前需要安装 hexo-server 插件$ npm install hexo-server --save 5:hexo deployhexo deploy 命令用于部署网站, 一般可以简写为 hexo d $ hexo deploy 6:hexo cleanhexo clean 命令用于清理缓存文件, 是一个比较常用的命令网站显示异常时可尝试此操作 7: Option(1) hexo –safehexo --safe 表示安全模式, 用于禁用加载插件和脚本$ hexo --safe安装新插件时遇到问题可尝试此操作(2) hexo –debughexo --debug 表示调试模式, 用于将消息详细记录到终端和debug.log文件(3)hexo –silenthexo --silent 表示静默模式, 用于静默输出到终端$ hexo --silent","link":"/2020/04/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"ABA的个数","text":"题意: 给一个只包含大写字母的字符串，求其中有多少个ABA(不一定连续)举个栗子: ABBBA 这个样例有3个ABA 样例: 输入: YARBRBAQTYAYBATTBLBZA 输出 26 思路:可以先把字符串中的A B取出，按原序放到一个新数组str[ ]中，然后依次预处理，A的数量，AB的数量，ABA的数量，我们可以开三个数组来处理他们，da[ ]，dab[]，daba[]，最终存ABA数量的数组可以由之前两个推出 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int inf = 1 &lt;&lt; 30;const int maxn = 1e6 + 5;typedef long long ll;//const int N = 5005;typedef unsigned long long ull;char s[maxn], str[maxn];ll da[maxn], dab[maxn], daba[maxn];int main(){ ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; s + 1; ll n = strlen(s + 1); ll cnt = 0; for (int i = 1; i &lt;= n; i++) { if (s[i] == 'A' || s[i] == 'B') str[++cnt] = s[i]; } for (int i = 1; i &lt;= cnt; i++) { if (str[i] == 'A') da[i] = da[i - 1] + 1; else da[i] = da[i - 1]; } for (int i = 1; i &lt;= cnt; i++) { if (str[i] == 'B') dab[i] = dab[i - 1] + da[i]; else dab[i] = dab[i - 1]; } for (int i = 1; i &lt;= cnt; i++) { if (str[i] == 'A') daba[i] = daba[i - 1] + dab[i]; else daba[i] = daba[i - 1]; } cout&lt;&lt;daba[cnt]&lt;&lt;endl;}","link":"/2020/04/19/ABA%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"HDU 3282 动态开点+区间第k小","text":"题意: 给n个数，把这n个数以此插入容器中，当插入的数量是奇数个时输出中位数 样例: Sample Input31 91 2 3 4 5 6 7 8 92 99 8 7 6 5 4 3 2 13 2323 41 13 22 -3 24 -31 -11 -8 -73 5 103 211 -311 -45 -67 -73 -81 -99-33 24 56 Sample Output1 51 2 3 4 52 59 8 7 6 53 1223 23 22 22 13 3 5 5 3 -3-7 -3 吐槽: 今天有点事，没看来得及看这道题，其实就是询问整体区间第k小的板题 思路: 我没怎么看数据范围，直接用动态开点线段树写了，当然这题数据范围很小，普通线段树也可以写，因为数据范围并不是很大，如果数据范围给到1e9，那也只能动态开点或者离散化写了，这题主要考察权值线段树，我们可以统计权值，我们询问的值如果小于等于左儿子节点的权值，呢么我们询问的值一定在左边，我们向左递归，反之减去左边权值向右递归 参考代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int inf = 1 &lt;&lt; 30;const int maxn = 1e6 + 5;typedef long long ll;const int N = 1005;typedef unsigned long long ull;//char s[maxn], str[maxn], s3[maxn];//char s[N][N];//ll da[maxn], dab[maxn], daba[maxn], sum[maxn];int a[maxn];struct node{ int ls, rs, sum;} tr[maxn &lt;&lt; 1];int cnt;void inser(int &amp;k, int L, int R, int pos){ if (!k) k = ++cnt; tr[k].sum++; if (L == R) { return; } int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[k].ls, L, mid, pos); else inser(tr[k].rs, mid + 1, R, pos);}int ask(int k, int L, int R, int ik){ if (L == R) { return L; } int mid = L + R &gt;&gt; 1; int sum = tr[tr[k].ls].sum; if (sum &gt;= ik) return ask(tr[k].ls, L, mid, ik); else return ask(tr[k].rs, mid + 1, R, ik - sum);}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, m, k; int t; cin &gt;&gt; t; while (t--) { memset(a, 0, sizeof a); memset(tr, 0, sizeof(tr)); cin &gt;&gt; m &gt;&gt; n; k = cnt = 0; int x, id = 0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; inser(k, -inf, inf, x); if (i &amp; 1) { int pos = (1 + i) / 2; a[id++] = ask(k, -inf, inf, pos); } } cout &lt;&lt; m &lt;&lt; ' ' &lt;&lt; (n + 1) / 2 ; for (int i = 0; i &lt;id; i++) { if (i % 10 == 0) cout &lt;&lt; endl; if (i % 10 == 0) cout &lt;&lt; a[i]; else cout &lt;&lt; ' ' &lt;&lt; a[i]; } cout&lt;&lt;endl; }}","link":"/2020/04/19/HDU-3282-%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9-%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%B0%8F/"}],"tags":[{"name":"ACM算法","slug":"ACM算法","link":"/tags/ACM%E7%AE%97%E6%B3%95/"}],"categories":[]}