{"pages":[],"posts":[{"title":"O(n)哈希检验求最长回文子串","text":"求最长回文子串，大家公认的算法是Manacher，但是如果我们不想学习Mangacher，又想在 O(n) 的时间复杂度下解决该问题怎么办？ 哈希算法可以帮我们做到，而且容易理解，代码还很短 举个栗子现在有字符串 str=&quot;cbaaab&quot;，我们要求它的回文子串，那么该怎么办呢？这里我们借用Manacher算法里的一个思想，向原字符串里插字符，使得这个字符串为奇数个，这样方便我们统一处理。我们在这个栗子中插入'#' 原字符:c b a a a b现字符:# c # b # a # a # a # b # 接下来: 先求出现字符串的正哈希 在求出现字符串的逆哈希 定义最长回文串半径 枚举字符串中的点 检验当前点的正哈希[i-l,i] 和 [i+l,i]是否相同 若相同扩大半径，反则退出循环 更新最大回文半径，记录ans 输出ans-1即可 推荐题目: 回文子串的最大长度 参考代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int inf = 1 &lt;&lt; 30;const int maxn = 2e6 + 5;typedef long long ll;//const int N = 5005;char s[maxn], str[maxn];typedef unsigned long long ull;ull h1[maxn], h2[maxn], p[maxn];int main(){ ios::sync_with_stdio(false); cin.tie(0); int id = 0; while (cin &gt;&gt; (s + 1) &amp;&amp; s[1] != 'E') { int n = strlen(s + 1); int t = 0; for (int i = 1; i &lt;= n; i++) { str[++t] = 'z'; str[++t] = s[i]; } str[++t] = 'z'; p[0] = 1ull; for (int i = 1; i &lt;= t; i++) { h1[i] = h1[i - 1] * 131ull + str[i] - 'a' + 1ull; h2[t - i + 1] = h2[t - i + 2] * 131ull + str[t - i + 1] - 'a' + 1ull; p[i] = p[i - 1] * 131ull; } int l, ans = 0, j = 0; for (int i = 1; i &lt;= t; i++) { l = ans; bool fla = false; while (h1[i] - h1[i - l] * p[l] == h2[i] - h2[i + l] * p[l] &amp;&amp; i + l &lt;= t &amp;&amp; i - l &gt;= 1) l++, fla = true; if (fla &amp;&amp; i + l &lt;= t &amp;&amp; i - l &gt;= 1) --l; ans = max(l, ans); } cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++id &lt;&lt; &quot;: &quot; &lt;&lt; ans - 1 &lt;&lt; endl; }}","link":"/2020/04/19/O-n-%E5%93%88%E5%B8%8C%E6%A3%80%E9%AA%8C%E6%B1%82%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"title":"线段树实现普通平衡树操作","text":"洛谷: 3369 (模板)普通平衡树题目描述:您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作: 1.插入 xx 数 2.删除 xx 数(若有多个相同的数，因只删除一个) 3.查询 xx 数的排名(排名定义为比当前数小的数的个数 +1+1 ) 4.查询排名为 xx 的数 5.求 xx 的前驱(前驱定义为小于 xx，且最大的数) 6.求 xx 的后继(后继定义为大于 xx，且最小的数) 输入格式第一行为 n，表示操作的个数,下面 n 行每行有两个数 opt 和 x，opt 表示操作的序号( 1&lt;=opt&lt;=6) 输出格式对于操作 3，4，5，6 每行输出一个数，表示对应答案 输入输出样例输入 #1 1234567891011101 1064654 11 3177211 4609291 6449851 841851 898516 819681 4927375 493598 输出 #1 12310646584185492737 数据范围 对于100%的数据，1&lt;=n&lt;=100000,|x|&lt;=10000000 思路: 用权值线段树，求整体区间的第k小，从而来实现1，2，4操作，然后利用前缀和的思路来求x的排名，从而实现3，5，6操作具体操作，参考以下代码 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 1e5 + 5;struct node{ int ls, rs, sum, lv, rv;} tr[maxn * 50];int cnt;void pushup(int k){ tr[k].sum = tr[tr[k].ls].sum + tr[tr[k].rs].sum;}void inser(int &amp;k, int L, int R, int pos, int w){ if (!k) k = ++cnt; if (L == R) { tr[k].sum += w; return; } int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[k].ls, L, mid, pos, w); else inser(tr[k].rs, mid + 1, R, pos, w); pushup(k);}int asik(int k, int L, int R, int ik){ if (L == R) return L; int mid = L + R &gt;&gt; 1; if (tr[tr[k].ls].sum &gt;= ik) return asik(tr[k].ls, L, mid, ik); else return asik(tr[k].rs, mid + 1, R, ik - tr[tr[k].ls].sum);}int ask(int k, int L, int R, int ql, int qr){ if (L &gt;= ql &amp;&amp; R &lt;= qr) { return tr[k].sum; } int mid = L + R &gt;&gt; 1; int ans = 0; if (ql &lt;= mid) ans += ask(tr[k].ls, L, mid, ql, qr); if (qr &gt; mid) ans += ask(tr[k].rs, mid + 1, R, ql, qr); return ans;}map&lt;int,int&gt;mp;int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, k = 0; cin &gt;&gt; n; while (n--) { int op, x; cin &gt;&gt; op &gt;&gt; x; if (op == 1) inser(k, -inf, inf, x, 1),mp[x]++; if (op == 2) inser(k, -inf, inf, x, -1),mp[x]--; if (op == 3) { inser(k, -inf, inf, x, 1),mp[x]++; int l = asik(k, -inf, inf, 1); cout &lt;&lt; ask(k, -inf, inf, l, x)-mp[x]+1&lt;&lt; endl; inser(k,-inf,inf,x,-1),mp[x]--; } if (op == 4) { cout &lt;&lt; asik(k, -inf, inf, x) &lt;&lt; endl; } if (op == 5) { inser(k, -inf, inf, x, 1),mp[x]++; int l = asik(k, -inf, inf, 1); int ans = ask(k, -inf, inf, l, x); cout &lt;&lt; asik(k, -inf, inf, ans - mp[x]) &lt;&lt; endl; inser(k, -inf, inf, x, -1),mp[x]--; } if (op == 6) { inser(k, -inf, inf, x, 1); int l = asik(k, -inf, inf, 1); int ans = ask(k, -inf, inf, l, x); cout &lt;&lt; asik(k, -inf, inf, ans+1) &lt;&lt; endl; inser(k, -inf, inf, x, -1); } }}","link":"/2020/04/24/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%AE%9E%E7%8E%B0%E6%99%AE%E9%80%9A%E5%B9%B3%E8%A1%A1%E6%A0%91%E6%93%8D%E4%BD%9C/"},{"title":"HDU 3282 动态开点+区间第k小","text":"题意: 给n个数，把这n个数以此插入容器中，当插入的数量是奇数个时输出中位数 样例: Sample Input31 91 2 3 4 5 6 7 8 92 99 8 7 6 5 4 3 2 13 2323 41 13 22 -3 24 -31 -11 -8 -73 5 103 211 -311 -45 -67 -73 -81 -99-33 24 56 Sample Output1 51 2 3 4 52 59 8 7 6 53 1223 23 22 22 13 3 5 5 3 -3-7 -3 吐槽: 今天有点事，没看来得及看这道题，其实就是询问整体区间第k小的板题 思路: 我没怎么看数据范围，直接用动态开点线段树写了，当然这题数据范围很小，普通线段树也可以写，因为数据范围并不是很大，如果数据范围给到1e9，那也只能动态开点或者离散化写了，这题主要考察权值线段树，我们可以统计权值，我们询问的值如果小于等于左儿子节点的权值，呢么我们询问的值一定在左边，我们向左递归，反之减去左边权值向右递归 参考代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int inf = 1 &lt;&lt; 30;const int maxn = 1e6 + 5;typedef long long ll;const int N = 1005;typedef unsigned long long ull;//char s[maxn], str[maxn], s3[maxn];//char s[N][N];//ll da[maxn], dab[maxn], daba[maxn], sum[maxn];int a[maxn];struct node{ int ls, rs, sum;} tr[maxn &lt;&lt; 1];int cnt;void inser(int &amp;k, int L, int R, int pos){ if (!k) k = ++cnt; tr[k].sum++; if (L == R) { return; } int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[k].ls, L, mid, pos); else inser(tr[k].rs, mid + 1, R, pos);}int ask(int k, int L, int R, int ik){ if (L == R) { return L; } int mid = L + R &gt;&gt; 1; int sum = tr[tr[k].ls].sum; if (sum &gt;= ik) return ask(tr[k].ls, L, mid, ik); else return ask(tr[k].rs, mid + 1, R, ik - sum);}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, m, k; int t; cin &gt;&gt; t; while (t--) { memset(a, 0, sizeof a); memset(tr, 0, sizeof(tr)); cin &gt;&gt; m &gt;&gt; n; k = cnt = 0; int x, id = 0; for (int i = 1; i &lt;= n; i++) { cin &gt;&gt; x; inser(k, -inf, inf, x); if (i &amp; 1) { int pos = (1 + i) / 2; a[id++] = ask(k, -inf, inf, pos); } } cout &lt;&lt; m &lt;&lt; ' ' &lt;&lt; (n + 1) / 2 ; for (int i = 0; i &lt;id; i++) { if (i % 10 == 0) cout &lt;&lt; endl; if (i % 10 == 0) cout &lt;&lt; a[i]; else cout &lt;&lt; ' ' &lt;&lt; a[i]; } cout&lt;&lt;endl; }}","link":"/2020/04/19/HDU-3282-%E5%8A%A8%E6%80%81%E5%BC%80%E7%82%B9-%E5%8C%BA%E9%97%B4%E7%AC%ACk%E5%B0%8F/"},{"title":"ABA的个数","text":"题意: 给一个只包含大写字母的字符串，求其中有多少个ABA(不一定连续)举个栗子: ABBBA 这个样例有3个ABA 样例: 输入: YARBRBAQTYAYBATTBLBZA 输出 26 思路:可以先把字符串中的A B取出，按原序放到一个新数组str[ ]中，然后依次预处理，A的数量，AB的数量，ABA的数量，我们可以开三个数组来处理他们，da[ ]，dab[]，daba[]，最终存ABA数量的数组可以由之前两个推出 参考代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;const int inf = 1 &lt;&lt; 30;const int maxn = 1e6 + 5;typedef long long ll;//const int N = 5005;typedef unsigned long long ull;char s[maxn], str[maxn];ll da[maxn], dab[maxn], daba[maxn];int main(){ ios::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; s + 1; ll n = strlen(s + 1); ll cnt = 0; for (int i = 1; i &lt;= n; i++) { if (s[i] == 'A' || s[i] == 'B') str[++cnt] = s[i]; } for (int i = 1; i &lt;= cnt; i++) { if (str[i] == 'A') da[i] = da[i - 1] + 1; else da[i] = da[i - 1]; } for (int i = 1; i &lt;= cnt; i++) { if (str[i] == 'B') dab[i] = dab[i - 1] + da[i]; else dab[i] = dab[i - 1]; } for (int i = 1; i &lt;= cnt; i++) { if (str[i] == 'A') daba[i] = daba[i - 1] + dab[i]; else daba[i] = daba[i - 1]; } cout&lt;&lt;daba[cnt]&lt;&lt;endl;}","link":"/2020/04/19/ABA%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"title":"我的第一篇博客","text":"Hexo 常用命令详解1:hexo inithexo init 命令用于初始化本地文件夹为网站的根目录 $ hexo init [folder] folder 可选参数, 可以指定初始化目录的路径, 若无指定则默认当前目录 2:hexo newhexo new 命令用于新建文章, 一般可以简写为 hexo n$ hexo new [layout] &lt;title&gt; layout 可选参数, 用以指定文章类型, 若无指定则默认由配置文件中的 default_layout选项决定 title 必填参数，可以用以指定文章标题，如果参数中含有空格，则需要使用双引号包围 3:hexo generatehexo generate 命令用于生成静态文件, 一般可以简写为hexo g$ hexo generate*-d 选项, 指定生成后部署，与hexo d -g等价 4:hexo serverhexo server 命令用于启动本地服务器, 一般可以简写为hexo s$ hexo server -p选项，指定服务器端口, 默认为 4000 -i选项，指定服务器 IP 地址, 默认为 0.0.0.0 -s选项, 静态模式 , 仅提供 public 文件夹中的文件并禁用文件监视 说明: 运行服务器前需要安装 hexo-server 插件$ npm install hexo-server --save 5:hexo deployhexo deploy 命令用于部署网站, 一般可以简写为 hexo d $ hexo deploy 6:hexo cleanhexo clean 命令用于清理缓存文件, 是一个比较常用的命令网站显示异常时可尝试此操作 7: Option(1) hexo –safehexo --safe 表示安全模式, 用于禁用加载插件和脚本$ hexo --safe安装新插件时遇到问题可尝试此操作(2) hexo –debughexo --debug 表示调试模式, 用于将消息详细记录到终端和debug.log文件(3)hexo –silenthexo --silent 表示静默模式, 用于静默输出到终端$ hexo --silent","link":"/2020/04/17/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"},{"title":"浅谈主席树","text":"主席树 我学习主席树，其实已经好几个月了，但是一直没有理解透彻，只能看着板子敲，今天有回顾了一下主席树，然后就突然有了新的理解。 主席树学习的前置技能 权值线段树 动态开点 权值线段树 学习权值线段树后，会了解求整体区间第k小，这个操作和主席树模板题中的求区间第k小操作是一样的 动态开点 首先主席树其实是一颗残树，但一般的线段树其实是预处理整个区间，所以一般建线段树的方法，并不适合建主席树，相反动态开点建树的方法，是可以在树的任何一个分支去建一条链的，原因在于，动态开点其实是给你一棵虚拟的树，我们按照我们要插入树中值的大小，在树中对应的位置，然后递归寻找这个位置，在找的过程中，把经过的点开出来，而且动态开点无需考虑数的大小，只需考虑数量 主席树 主席树其实的思想其实就是权值线段树，权值线段树可以求整体区间的第k小，原因在于，我们已知整体区间中不同区间的数的个数，呢么主席树因为有动态开点和权值线段树加持，我们可以，用动态开点建立n个版本的残缺线段树，如果我们要询问区间的第k小，我们就可以在l-r版本的残缺线段树中进行，权值线段树的操作，这点和前缀和思路一样 模板题 参考代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;const int inf = (1 &lt;&lt; 30);typedef long long ll;const int maxn = 2e5 + 5;int rt[maxn], cnt;struct node{ int ls, rs, sum;} tr[maxn * 40];void inser(int ver, int &amp;now, int L, int R, int pos){ now = ++cnt; tr[now] = tr[ver]; tr[now].sum++; if (L == R) return; int mid = L + R &gt;&gt; 1; if (mid &gt;= pos) inser(tr[ver].ls, tr[now].ls, L, mid, pos); else inser(tr[ver].rs, tr[now].rs, mid + 1, R, pos);}int ask(int ver, int now, int L, int R, int pos){ if (L == R) return L; int mid = L + R &gt;&gt; 1; int sum = tr[tr[now].ls].sum - tr[tr[ver].ls].sum; if (sum &gt;= pos) return ask(tr[ver].ls, tr[now].ls, L, mid, pos); else return ask(tr[ver].rs, tr[now].rs, mid + 1, R, pos - sum);}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n, x, q; cin &gt;&gt; n &gt;&gt; q; for (int i = 1; i &lt;= n; i++) cin &gt;&gt; x, inser(rt[i - 1], rt[i], -inf, inf, x); while (q--) { int ql, qr, ik; cin &gt;&gt; ql &gt;&gt; qr &gt;&gt; ik; cout &lt;&lt; ask(rt[ql - 1], rt[qr], -inf, inf, ik) &lt;&lt; endl; }}","link":"/2020/04/24/%E6%B5%85%E8%B0%88%E4%B8%BB%E5%B8%AD%E6%A0%91/"}],"tags":[{"name":"ACM算法","slug":"ACM算法","link":"/tags/ACM%E7%AE%97%E6%B3%95/"}],"categories":[]}